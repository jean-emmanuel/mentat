<!DOCTYPE html>
<html  dir="ltr">

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mentat</title>
        <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
        <link rel="apple-touch-icon-precomposed" href="images/apple-touch-icon.png">
        <meta name="generator" content="pandoc-uikit" />
                        <title>Mentat</title>
        <style>
            :root {
                --color-text: #333;
                --color-accent: #0090c0;
                --side-width: 300px;
                --p-margin: 20px
            }
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                /* font: inherit; */
            }
            body {
                display: flex;
                flex-direction: row;
                width: 960px;
                /* margin: var(--p-margin) auto 0; */

                font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
                line-height: 1.5;
                font-size: 14px;
                color: var(--color-text);
            }
            aside {
                width: var(--side-width);
                margin-right: 20px;
                background: #eee;
            }
            main {
                flex: 1;
                padding-top: var(--p-margin);
                min-width: 0;
            }

            aside ul {
                list-style: none;
            }
            aside > ul {
                list-style: none;
                position: fixed;
                top: 0;
                width: calc(var(--side-width));
                height: 100%;
                padding-top: var(--p-margin);
                overflow-y: auto;
                overflow-x: hidden;
                padding-left: 0;
                white-space: nowrap;
            }
            aside > ul > li {
                margin-left: var(--p-margin);
            }
            aside li {
                margin: 0;
            }
            ul, ol {
                padding-left: 20px;
            }
            main ul ul {
                margin-bottom: 0;
            }
            h1, h2, h3, ul, pre, p {
                margin-bottom: var(--p-margin);
            }
            hr {
                margin: calc(2 * var(--p-margin)) 0;
                opacity: 0.5;
            }
            a {
                text-decoration: none
            }
            aside a {
                color: inherit;
            }
            aside a:hover, main a {
                color: var(--color-accent);
            }
            h1, h2, h3 {
                padding-top: var(--p-margin);
                margin-top: calc(-1 * var(--p-margin));
            }
            .content {
                padding-left: 20px;
            }
            pre, code {
                background: #eee;
                padding: 0 2px;
                border: 1px solid rgba(0,0,0,0.05);
            }
            pre code {
                padding: 0;
                background: none;
                border: none;
            }
            .version {
                opacity: 0.5;
            }
        </style>
    </head>

    <body>

        <aside>
                        <ul>
                        <li><a href="#mentat" id="toc-mentat">Mentat</a>
                        <ul>
                        <li><a href="#overview"
                        id="toc-overview">Overview</a></li>
                        <li><a href="#requirements"
                        id="toc-requirements">Requirements</a></li>
                        <li><a href="#install"
                        id="toc-install">Install</a></li>
                        <li><a href="#usage"
                        id="toc-usage">Usage</a></li>
                        <li><a href="#generic-control-api"
                        id="toc-generic-control-api">Generic control
                        API</a></li>
                        <li><a href="#midi" id="toc-midi">MIDI</a></li>
                        </ul></li>
                        <li><a href="#engine" id="toc-engine">Engine</a>
                        <ul>
                        <li><a href="#engine-1"
                        id="toc-engine-1">Engine()</a></li>
                        <li><a href="#engine.start"
                        id="toc-engine.start">Engine.start()</a></li>
                        <li><a href="#engine.stop"
                        id="toc-engine.stop">Engine.stop()</a></li>
                        <li><a href="#engine.restart"
                        id="toc-engine.restart">Engine.restart()</a></li>
                        <li><a href="#engine.autorestart"
                        id="toc-engine.autorestart">Engine.autorestart()</a></li>
                        <li><a href="#engine.add_module"
                        id="toc-engine.add_module">Engine.add_module()</a></li>
                        <li><a href="#engine.send"
                        id="toc-engine.send">Engine.send()</a></li>
                        <li><a href="#engine.add_route"
                        id="toc-engine.add_route">Engine.add_route()</a></li>
                        <li><a href="#engine.set_route"
                        id="toc-engine.set_route">Engine.set_route()</a></li>
                        <li><a href="#engine.route"
                        id="toc-engine.route">Engine.route()</a></li>
                        <li><a href="#engine.set_tempo"
                        id="toc-engine.set_tempo">Engine.set_tempo()</a></li>
                        <li><a href="#engine.set_cycle_length"
                        id="toc-engine.set_cycle_length">Engine.set_cycle_length()</a></li>
                        <li><a href="#engine.set_time_signature"
                        id="toc-engine.set_time_signature">Engine.set_time_signature()</a></li>
                        <li><a href="#engine.start_cycle"
                        id="toc-engine.start_cycle">Engine.start_cycle()</a></li>
                        <li><a href="#engine.fastforward"
                        id="toc-engine.fastforward">Engine.fastforward()</a></li>
                        </ul></li>
                        <li><a href="#module" id="toc-module">Module</a>
                        <ul>
                        <li><a href="#module-1"
                        id="toc-module-1">Module()</a></li>
                        <li><a href="#module.add_submodule"
                        id="toc-module.add_submodule">Module.add_submodule()</a></li>
                        <li><a href="#module.set_aliases"
                        id="toc-module.set_aliases">Module.set_aliases()</a></li>
                        <li><a href="#module.add_parameter"
                        id="toc-module.add_parameter">Module.add_parameter()</a></li>
                        <li><a href="#module.remove_parameter"
                        id="toc-module.remove_parameter">Module.remove_parameter()</a></li>
                        <li><a href="#module.get"
                        id="toc-module.get">Module.get()</a></li>
                        <li><a href="#module.set"
                        id="toc-module.set">Module.set()</a></li>
                        <li><a href="#module.reset"
                        id="toc-module.reset">Module.reset()</a></li>
                        <li><a href="#module.animate"
                        id="toc-module.animate">Module.animate()</a></li>
                        <li><a href="#module.stop_animate"
                        id="toc-module.stop_animate">Module.stop_animate()</a></li>
                        <li><a href="#module.add_mapping"
                        id="toc-module.add_mapping">Module.add_mapping()</a></li>
                        <li><a href="#module.add_meta_parameter"
                        id="toc-module.add_meta_parameter">Module.add_meta_parameter()</a></li>
                        <li><a href="#module.add_alias_parameter"
                        id="toc-module.add_alias_parameter">Module.add_alias_parameter()</a></li>
                        <li><a href="#module.get_state"
                        id="toc-module.get_state">Module.get_state()</a></li>
                        <li><a href="#module.set_state"
                        id="toc-module.set_state">Module.set_state()</a></li>
                        <li><a href="#module.send_state"
                        id="toc-module.send_state">Module.send_state()</a></li>
                        <li><a href="#module.save"
                        id="toc-module.save">Module.save()</a></li>
                        <li><a href="#module.load"
                        id="toc-module.load">Module.load()</a></li>
                        <li><a href="#module.route"
                        id="toc-module.route">Module.route()</a></li>
                        <li><a href="#module.send"
                        id="toc-module.send">Module.send()</a></li>
                        <li><a href="#module.start_scene"
                        id="toc-module.start_scene">Module.start_scene()</a></li>
                        <li><a href="#module.restart_scene"
                        id="toc-module.restart_scene">Module.restart_scene()</a></li>
                        <li><a href="#module.stop_scene"
                        id="toc-module.stop_scene">Module.stop_scene()</a></li>
                        <li><a href="#module.wait"
                        id="toc-module.wait">Module.wait()</a></li>
                        <li><a href="#module.wait_next_cycle"
                        id="toc-module.wait_next_cycle">Module.wait_next_cycle()</a></li>
                        <li><a href="#module.lock"
                        id="toc-module.lock">Module.lock()</a></li>
                        <li><a href="#module.run"
                        id="toc-module.run">Module.run()</a></li>
                        <li><a href="#module.play_sequence"
                        id="toc-module.play_sequence">Module.play_sequence()</a></li>
                        <li><a href="#module.add_event_callback"
                        id="toc-module.add_event_callback">Module.add_event_callback()</a></li>
                        <li><a href="#module.dispatch_event"
                        id="toc-module.dispatch_event">Module.dispatch_event()</a></li>
                        </ul></li>
                        <li><a href="#route" id="toc-route">Route</a>
                        <ul>
                        <li><a href="#route-1"
                        id="toc-route-1">Route()</a></li>
                        <li><a href="#route.activate"
                        id="toc-route.activate">Route.activate()</a></li>
                        <li><a href="#route.deactivate"
                        id="toc-route.deactivate">Route.deactivate()</a></li>
                        <li><a href="#route.route"
                        id="toc-route.route">Route.route()</a></li>
                        <li><a href="#route.start_scene"
                        id="toc-route.start_scene">Route.start_scene()</a></li>
                        <li><a href="#route.restart_scene"
                        id="toc-route.restart_scene">Route.restart_scene()</a></li>
                        <li><a href="#route.stop_scene"
                        id="toc-route.stop_scene">Route.stop_scene()</a></li>
                        <li><a href="#route.wait"
                        id="toc-route.wait">Route.wait()</a></li>
                        <li><a href="#route.wait_next_cycle"
                        id="toc-route.wait_next_cycle">Route.wait_next_cycle()</a></li>
                        <li><a href="#route.lock"
                        id="toc-route.lock">Route.lock()</a></li>
                        <li><a href="#route.run"
                        id="toc-route.run">Route.run()</a></li>
                        <li><a href="#route.play_sequence"
                        id="toc-route.play_sequence">Route.play_sequence()</a></li>
                        </ul></li>
                        </ul>
                    </aside>

        <main>
<h2 id="mentat">Mentat</h2>
<div class="version">
<p>Version: 1.6.1 (13/10/2024) <br/> License: GNU/GPL v3 (© 2024
Jean-Emmanuel Doucet)</p>
</div>
<h3 id="overview">Overview</h3>
<p>Mentat is a HUB / Conductor for OSC / MIDI capable softwares. It aims
to centralize all controls in one place, manage their state and create
routings.</p>
<p>Mentat is a module for <a href="https://www.python.org/">python 3</a>
and requires writing code to work. If you’re looking for a
fully-featured software with a user interface, try <a
href="https://benjamin.kuperberg.fr/chataigne/en">Chataigne</a>
instead.</p>
<p>Mentat has been designed to coordinate the live setup of the
rap-in-opposition band <a href="https://plagiat.org/clips">Plagiat</a>
(see the project’s <a
href="https://github.com/PlagiatBros/PlagiatSetupII/">source
repository</a>).</p>
<h3 id="requirements">Requirements</h3>
<pre><code>python3 python3-pyalsa python3-pyinotify</code></pre>
<h3 id="install">Install</h3>
<pre><code>git clone https://github.com/jean-emmanuel/mentat/
cd mentat
python3 setup.py install</code></pre>
<h3 id="usage">Usage</h3>
<p>The typical use case for Mentat is a conductor for controlling a set
of softwares during a live performance.</p>
<p>The <a href="#engine"><code>Engine</code></a> object is the main
object, it manages the OSC / MIDI backends, the modules and the routes.
It also holds a tempo, a cycle length (measure) and a time reference
that’s used to create timed scenes and sequences in a musical way (using
beats instead of seconds).</p>
<p><a href="#module"><code>Module</code></a> objects are interfaces
between the controlled softwares and the engine. The <code>Module</code>
class should be subclassed to create dedicated module classes for
different softwares.</p>
<p>A set of controllable parameters can be defined for each module, each
parameter being an alias for an OSC / MIDI value in the controlled
software.</p>
<p>Controlled parameters should only modified using the module’s <a
href="#module.set"><code>set()</code></a> and <a
href="#module.animate"><code>animate()</code></a> methods in order to
guarantee that the state of the modules reflects the actual state of the
softwares. This removes the need for feedback from said softwares and
allows us to trust Mentat as the source of truth during the
performance.</p>
<p>All messages received by the engine that are coming from a software
associated with a module are first passed to that module’s <a
href="#module.route"><code>route()</code></a> method.</p>
<p><a href="#route"><code>Route</code></a> objects represent the
different parts of the performance (eg tracks / songs in a musical
show). The <code>Engine</code> has one active route at a time and will
pass all incoming messages to its <a
href="#route.route"><code>route()</code></a> method.</p>
<p>Each track should be a dedicated class derived from the
<code>Route</code> class. The <a
href="#route.route"><code>route()</code></a> method definition will
allow writing the actual routing that should occur during that
track.</p>
<h3 id="generic-control-api">Generic control API</h3>
<p>In order to ensure state consistency, parameters should always be
controlled by mentat. A generic command is exposed to control modules
using osc messages, it allows calling any method owned by the engine and
its modules:</p>
<p><code>/engine_name/module_name/submodule_name/method_name &lt;*arguments&gt;</code></p>
<p><strong>Examples</strong></p>
<pre><code>/engine_name/set_route route_name
/engine_name/module_name/set parameter_name 1.0
/engine_name/module_name/submodule_name/animate parameter_name 1.0 10.0 1.0</code></pre>
<h3 id="midi">MIDI</h3>
<p>Mentat treats MIDI messages as OSC messages. Modules with protocol
set to <code>'midi'</code> will send and receive messages formatted as
follows:</p>
<pre><code>/note_on &lt;int: channel&gt; &lt;int: note&gt; &lt;int: velocity&gt;
/note_off &lt;int: channel&gt; &lt;int: note&gt;
/control_change &lt;int: channel&gt; &lt;int: control&gt; &lt;int: value&gt;
/program_change &lt;int: channel&gt; &lt;int: program&gt;
/pitch_bend  &lt;int: channel&gt; &lt;int: pitch&gt;
/sysex &lt;*int: values&gt;</code></pre>
<hr />
<h2 id="engine">Engine</h2>
<p>Main object. Singleton that must be instanciated before any
<code>Module</code> or <code>Route</code> object. The global engine
instance is always accessible via <code>Engine.INSTANCE</code>.</p>
<p>The engine is also a <code>Module</code> instance and can use the
methods of this class.</p>
<p><strong>Instance properties</strong></p>
<ul>
<li><code>modules</code>: <code>dict</code> containing modules added to
the engine with names as keys</li>
<li><code>routes</code>: <code>dict</code> containing routes added to
the engine with names as keys</li>
<li><code>active_route</code>: active route object (<code>None</code> by
default)</li>
<li><code>restarted</code>: <code>True</code> if the engine was
restarted using <code>autorestart()</code></li>
<li><code>logger</code>: python logger</li>
<li><code>tempo</code>: beats per minute</li>
<li><code>cycle_length</code>: quarter notes per cycle</li>
<li><code>port</code>: osc (udp) input port number</li>
<li><code>tcp_port</code>: osc (tcp) input port number</li>
<li><code>unix_port</code>: osc (unix) input socket path</li>
</ul>
<p><strong>Events</strong></p>
<ul>
<li><code>started</code>: emitted when the engine starts.</li>
<li><code>stopping</code>: emitted before the engine stops</li>
<li><code>stopped</code>: emitted when the engine is stopped</li>
<li><code>route_added</code>: emitted when a route is added to the
engine. Arguments:
<ul>
<li><code>route</code>: route instance</li>
</ul></li>
<li><code>route_changed</code>: emitted when the engine’s active route
changes. Arguments:
<ul>
<li><code>name</code>: active route instance</li>
</ul></li>
</ul>
<h3 id="engine-1">Engine()</h3>
<div class="content">
<p><i>Engine(name, port, folder, debug=False, tcp_port=None,
unix_port=None)</i><br/></p>
<p>Engine constructor.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: client name</li>
<li><code>port</code>: osc (udp) input port number</li>
<li><code>folder</code>: path to config folder where state files will be
saved to and loaded from</li>
<li><code>debug</code>: set to True to enable debug messages and i/o
statistics</li>
<li><code>tcp_port</code>: osc (tcp) input port number</li>
<li><code>unix_port</code>: osc (unix) input socket path</li>
</ul>
</div>
<h3 id="engine.start">Engine.start()</h3>
<div class="content">
<p><i>start()</i><br/></p>
<p>Start engine. This is usually the last statement in the script as it
starts the processing loop that keeps the engine running.</p>
</div>
<h3 id="engine.stop">Engine.stop()</h3>
<div class="content">
<p><i>stop()</i><br/></p>
<p>Stop engine. This is called automatically when the process is
terminated or when the engine restarts.</p>
</div>
<h3 id="engine.restart">Engine.restart()</h3>
<div class="content">
<p><i>restart()</i><br/></p>
<p>Stop the engine and restart once the process is terminated.</p>
</div>
<h3 id="engine.autorestart">Engine.autorestart()</h3>
<div class="content">
<p><i>autorestart()</i><br/></p>
<p>Enable engine autorestart. This watches the main python script and
all imported modules that are located in the same directoty. Whenever a
file is modified, the engine is restarted.</p>
</div>
<h3 id="engine.add_module">Engine.add_module()</h3>
<div class="content">
<p><i>add_module(module)</i><br/></p>
<p>Add a module. This method will create midi ports if the module’s
protocol is ‘midi’.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>module</code>: Module object</li>
</ul>
</div>
<h3 id="engine.send">Engine.send()</h3>
<div class="content">
<p><i>send(protocol, port, address, *args)</i><br/></p>
<p>Send OSC / MIDI message.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>protocol</code>: ‘osc’, ‘osc.tcp’, ‘osc.unix’ or ‘midi’</li>
<li><code>port</code>: module name, port number (‘osc’ protocol only) or
unix socket path (‘osc.unix’ protocol only)</li>
<li><code>address</code>: osc address</li>
<li><code>args</code>: values or (typetag, value) tuples</li>
</ul>
</div>
<h3 id="engine.add_route">Engine.add_route()</h3>
<div class="content">
<p><i>add_route(route)</i><br/></p>
<p>Add a route.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>route</code>: Route object</li>
</ul>
</div>
<h3 id="engine.set_route">Engine.set_route()</h3>
<div class="content">
<p><i>set_route(name)</i><br/></p>
<p>Set active route.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: route name</li>
</ul>
</div>
<h3 id="engine.route">Engine.route()</h3>
<div class="content">
<p><i>route(protocol, port, address, args)</i><br/></p>
<p>Unified route for osc and midi messages, called when the engine
receives a midi or osc message. Messages are processed this way :</p>
<ol type="1">
<li><p>If the message is sent from a port that matches a module’s, the
message is passed to that module’s route method. If it returns
<code>False</code>, further processing is prevented.</p></li>
<li><p>If the address matches a command as per the generic control API,
further processing is prevented.</p></li>
<li><p>If a route is active, the message is passed to that route’s route
method.</p></li>
</ol>
<p><strong>Parameters</strong></p>
<ul>
<li><code>protocol</code>: ‘osc’, ‘osc.tcp’ or ‘midi’</li>
<li><code>port</code>: name of module or port number if unknown</li>
<li><code>address</code>: osc address</li>
<li><code>args</code>: list of values</li>
</ul>
</div>
<h3 id="engine.set_tempo">Engine.set_tempo()</h3>
<div class="content">
<p><i>set_tempo(bpm)</i><br/></p>
<p>Set engine tempo.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>bpm</code>: beats per minute</li>
</ul>
</div>
<h3 id="engine.set_cycle_length">Engine.set_cycle_length()</h3>
<div class="content">
<p><i>set_cycle_length(quarter_notes)</i><br/></p>
<p>Set engine cycle (measure) length in quarter notes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>quarter_notes</code>: quarter notes per cycle (decimals
allowed)</li>
</ul>
</div>
<h3 id="engine.set_time_signature">Engine.set_time_signature()</h3>
<div class="content">
<p><i>set_time_signature(signature)</i><br/></p>
<p>Set engine cycle (measure) length from a musical time signature.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>signature</code>: <code>string</code> like ‘4/4’, ‘5/4’,
‘7/8’…</li>
</ul>
</div>
<h3 id="engine.start_cycle">Engine.start_cycle()</h3>
<div class="content">
<p><i>start_cycle()</i><br/></p>
<p>Set current time as cycle start. Affects Route.wait_next_cycle()
method.</p>
</div>
<h3 id="engine.fastforward">Engine.fastforward()</h3>
<div class="content">
<p><i>fastforward(amount, mode=‘beats’)</i><br/></p>
<p><code>/!\ Experimental /!\</code></p>
<p>Increment current time by a number of beats or seconds. All parameter
animations and wait() calls will be affected.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>duration</code>: number of beats or seconds</li>
<li><code>mode</code>: ‘beats’ or ‘seconds’ (only the first letter
matters)</li>
</ul>
</div>
<hr />
<h2 id="module">Module</h2>
<p>Interface between a software / hardware and the engine.</p>
<p><strong>Instance properties</strong></p>
<ul>
<li><code>engine</code>: Engine instance</li>
<li><code>logger</code>: python logger</li>
<li><code>name</code>: module name</li>
<li><code>parent_module</code>: parent module instance,
<code>None</code> if the module is not a submodule</li>
<li><code>module_path</code>: list of module names, from topmost parent
(engine) to submodule</li>
<li><code>submodules</code>: <code>dict</code> containing submodules
added to the module with names as keys</li>
<li><code>parameters</code>: <code>dict</code> containing parameters
added to the module with names as keys</li>
<li><code>meta_parameters</code>: <code>dict</code> containing meta
parameters added to the module with names as keys</li>
</ul>
<p><strong>Events</strong></p>
<ul>
<li><code>module_added</code>: emitted when a submodule is added to a
module. Arguments:
<ul>
<li><code>module</code>: instance of parent module</li>
<li><code>submodule</code>: instace of child module</li>
</ul></li>
<li><code>parameter_added</code>: emitted when a parameter is added to a
module. Arguments:
<ul>
<li><code>module</code>: instance of module that emitted the event</li>
<li><code>name</code>: name of parameter</li>
</ul></li>
<li><code>parameter_changed</code>: emitted when a module’s parameter
changes. Arguments:
<ul>
<li><code>module</code>: instance of module that emitted the event</li>
<li><code>name</code>: name of parameter</li>
<li><code>value</code>: value of parameter or list of values</li>
</ul></li>
</ul>
<h3 id="module-1">Module()</h3>
<div class="content">
<p><i>Module(name, protocol=None, port=None, parent=None)</i><br/></p>
<p>Base Module constructor.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: module name</li>
<li><code>protocol</code>: ‘osc’, ‘osc.tcp’, ‘osc.unix’ or ‘midi’</li>
<li><code>port</code>: port used by the software / hardware to send and
receive messages
<ul>
<li>port number if protocol is ‘osc’ or ‘osc.tcp’</li>
<li>unix socket path if protocol is ‘osc.unix’</li>
<li><code>None</code> if protocol is ‘midi’ or if no port is needed</li>
</ul></li>
<li><code>parent</code>: if the module is a submodule, this must be set
to the parent module’s instance</li>
</ul>
</div>
<h3 id="module.add_submodule">Module.add_submodule()</h3>
<div class="content">
<p><i>add_submodule(*modules)</i><br/></p>
<p>Add a submodule.</p>
<p>Submodule’s protocol and port can be omitted, in which case they will
be inherited from their parent.</p>
<p>A submodule can send messages but it will not receive messages
through its route method.</p>
<p>The submodule’s parent instance must be provided in its constructor
function (<code>parent</code> argument).</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>modules</code>: Module objects (one module per argument)</li>
</ul>
</div>
<h3 id="module.set_aliases">Module.set_aliases()</h3>
<div class="content">
<p><i>set_aliases(aliases)</i><br/></p>
<p>Set aliases for submodules. Aliases can be used in place of the
submodule_name argument in some methods.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>aliases</code>: {alias: name} dictionary</li>
</ul>
</div>
<h3 id="module.add_parameter">Module.add_parameter()</h3>
<div class="content">
<p><i>add_parameter(name, address, types, static_args=[],
default=None)</i><br/></p>
<p>Add parameter to module.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: name of parameter</li>
<li><code>address</code>: osc address of parameter (<code>None</code> if
the parameter should not send any message)</li>
<li><code>types</code>: osc typetags string, one letter per value,
including static values (character ’*’ can be used for arguments that
should not be explicitely typed)</li>
<li><code>static_args</code>: list of static values before the ones that
can be modified</li>
<li><code>default</code>: value or list of values if the parameter has
multiple dynamic values</li>
</ul>
</div>
<h3 id="module.remove_parameter">Module.remove_parameter()</h3>
<div class="content">
<p><i>remove_parameter(name)</i><br/></p>
<p>Remove parameter from module.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: name of parameter, ’*’ to delete all
parameters</li>
</ul>
</div>
<h3 id="module.get">Module.get()</h3>
<div class="content">
<p><i>get(parameter_name)</i><br/> <i>get(submodule_name,
param_name)</i><br/></p>
<p>Get value of parameter</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>parameter_name</code>: name of parameter</li>
<li><code>submodule_name</code>: name of submodule</li>
</ul>
<p><strong>Return</strong></p>
<p>List of values</p>
</div>
<h3 id="module.set">Module.set()</h3>
<div class="content">
<p><i>set(parameter_name, <em>args, force_send=False,
preserve_animation=False)</i><br/> <i>set(submodule_name,
parameter_name, </em>args, force_send=False,
preserve_animation=False)</i><br/></p>
<p>Set value of parameter.</p>
<p>The engine will trigger events related to the value change only at
the end of current processing cycle and send a message if the new value
differs from the one that was previously sent.</p>
<p>When in a scene, subsequent calls to <code>set()</code> are not
guaranteed to be executed within the same processing cycle. (see
<code>lock()</code>)</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>parameter_name</code>: name of parameter</li>
<li><code>submodule_name</code>: name of submodule, with wildcard (’*‘)
and range (’[]’) support</li>
<li><code>*args</code>: value(s)</li>
<li><code>force_send</code>: send a message even if the parameter’s
value has not changed</li>
<li><code>preserve_animation</code>: by default, animations are
automatically stopped when <code>set()</code> is called, set to
<code>True</code> to prevent that</li>
</ul>
</div>
<h3 id="module.reset">Module.reset()</h3>
<div class="content">
<p><i>reset(parameter_name=None)</i><br/> <i>reset(submodule_name,
parameter_name=None)</i><br/></p>
<p>Reset parameter to its default values.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>submodule_name</code>: name of submodule, with wildcard (’*‘)
and range (’[]’) support</li>
<li><code>parameter_name</code>: name of parameter. If omitted, affects
all parameters including submodules’</li>
</ul>
</div>
<h3 id="module.animate">Module.animate()</h3>
<div class="content">
<p><i>animate(parameter_name, start, end, duration, mode=‘beats’,
easing=‘linear’, loop=False)</i><br/> <i>animate(submodule_name,
parameter_name, start, end, duration, mode=‘beats’, easing=‘linear’,
loop=False)</i><br/></p>
<p>Animate parameter.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>parameter_name</code>: name of parameter</li>
<li><code>submodule_name</code>: name of submodule, with wildcard (’*‘)
and range (’[]’) support</li>
<li><code>start</code>: starting value(s), can be None to use current
value (only for single value parameters)</li>
<li><code>end</code>: ending value(s), can be None to use current value
(only for single value parameters)</li>
<li><code>duration</code>: animation duration</li>
<li><code>mode</code>: ‘seconds’ or ‘beats’</li>
<li><code>easing</code>: easing function name.
<ul>
<li>available easings: linear, sine, quadratic, cubic, quartic, quintic,
exponential, random, elastic (sinc)</li>
<li>easing name can be suffixed with <code>-mirror</code> (back and
forth animation)</li>
<li>easing name can be suffixed with <code>-out</code> (inverted and
flipped easing) or <code>-inout</code> (linear interpolation between
default and <code>-out</code>). Example:
<code>exponential-mirror-inout</code>.</li>
</ul></li>
<li><code>loop</code>: if set to <code>True</code>, the animation will
start over when <code>duration</code> is reached (use mirror easing for
back-and-forth loop)</li>
</ul>
</div>
<h3 id="module.stop_animate">Module.stop_animate()</h3>
<div class="content">
<p><i>stop_animate(parameter_name)</i><br/>
<i>stop_animate(submodule_name, param_name)</i><br/></p>
<p>Stop parameter animation.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>parameter_name</code>: name of parameter, can be ’*’ to stop
all animations including submodules’.</li>
<li><code>submodule_name</code>: name of submodule</li>
</ul>
</div>
<h3 id="module.add_mapping">Module.add_mapping()</h3>
<div class="content">
<p><i>add_mapping(src, dest, transform, inverse=None)</i><br/></p>
<p>Add a value mapping between two or more parameters owned by the
module or one of its submodules. Whenever a value change occurs in one
of the source parameters, <code>transform</code> will be called and its
result will be dispatched to the destination parameters.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>src</code>: source parameter(s), can be
<ul>
<li><code>string</code> if there’s only one source parameter owned by
the module itself</li>
<li><code>tuple</code> of <code>string</code> if the source parameter is
owned by a submodule
(e.g. <code>('submodule_name', 'parameter_name')</code>)</li>
<li><code>list</code> containing either of the above if there are
multiple source parameters.</li>
</ul></li>
<li><code>dest</code>: destination parameter(s), see
<code>src</code></li>
<li><code>transform</code>: function that takes one argument per source
parameter and returns a value for the destination parameters or a list
if there are multiple destination parameters.</li>
<li><code>inverse</code>: same as <code>transform</code> but for
updating source parameters when destination parameters update. If
<code>transform</code> and <code>inverse</code> are inconsistent
(e.g. <code>transform(inverse(x)) != x</code>), mappings will not
trigger each others indefinetely (a mapping cannot run twice during a
cycle).</li>
</ul>
</div>
<h3 id="module.add_meta_parameter">Module.add_meta_parameter()</h3>
<div class="content">
<p><i>add_meta_parameter(name, parameters, getter, setter)</i><br/></p>
<p>Add a special parameter whose value depends on the state of one or
several parameters owned by the module or its submodules.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: name of meta parameter</li>
<li><code>parameters</code>: parameters involved in the meta parameter’s
definition, can be
<ul>
<li><code>string</code> if there’s only one source parameter owned by
the module itself</li>
<li><code>tuple</code> of <code>string</code> if the source parameter is
owned by a submodule
(e.g. <code>('submodule_name', 'parameter_name')</code>)</li>
<li><code>list</code> containing either of the above if there are
multiple source parameters.</li>
</ul></li>
<li><code>getter</code>: callback function that will be called with the
values of each <code>parameters</code> as arguments whenever one these
parameters changes. Its return value will define the meta parameter’s
value.</li>
<li><code>setter</code>: callback function used to set the value of each
<code>parameters</code> when <code>set()</code> is called to change the
meta parameter’s value. The function’s signature must not use *args or
**kwargs arguments.</li>
</ul>
</div>
<h3 id="module.add_alias_parameter">Module.add_alias_parameter()</h3>
<div class="content">
<p><i>add_alias_parameter(name, parameter)</i><br/></p>
<p>Add a special parameter that just mirrors another parameter owned by
the module or its submodules. Under the hood, this creates a parameter
and a 1:1 mapping between them.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: name of alias parameter</li>
<li><code>parameter</code>: name of parameter to mirror, may a be tuple
if the parameter are owned by a submodule
(<code>('submodule_name', 'parameter_name')</code>)</li>
</ul>
</div>
<h3 id="module.get_state">Module.get_state()</h3>
<div class="content">
<p><i>get_state()</i><br/></p>
<p>Get state of all parameters and submodules’ parameters.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>omit_defaults</code>: set to <code>True</code> to only
retreive parameters that differ from their default values.</li>
</ul>
<p><strong>Return</strong></p>
<p>List of lists that can be fed to set()</p>
</div>
<h3 id="module.set_state">Module.set_state()</h3>
<div class="content">
<p><i>set_state(state)</i><br/></p>
<p>Set state of any number of parameters and submodules’ parameters.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>state</code>: state object as returned by
<code>get_state()</code></li>
<li><code>force_send</code>: see <code>set()</code></li>
</ul>
</div>
<h3 id="module.send_state">Module.send_state()</h3>
<div class="content">
<p><i>send_state()</i><br/></p>
<p>Send current state of all parameters and submodules’ parameters.</p>
</div>
<h3 id="module.save">Module.save()</h3>
<div class="content">
<p><i>save(name, omit_defaults=False)</i><br/></p>
<p>Save current state (including submodules) to a JSON file.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: name of state save (without file extension)</li>
<li><code>omit_defaults</code>: set to <code>True</code> to only save
parameters that differ from their default values.</li>
</ul>
</div>
<h3 id="module.load">Module.load()</h3>
<div class="content">
<p><i>load(name, force_send=False)</i><br/></p>
<p>Load state from memory or from file if not preloaded already. The
file must be valid a JSON file containing one list of lists as returned
by <code>get_state()</code>. Comments may be added manually by inserting
string items in the main list:</p>
<pre><code>[
    &quot;This is a comment&quot;,
    [&quot;parameter_a&quot;, 1.0],
    [&quot;parameter_b&quot;, 2.0],
    &quot;etc&quot;
]</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: name of state save (without file extension)</li>
<li><code>force_send</code>: see <code>set()</code></li>
</ul>
</div>
<h3 id="module.route">Module.route()</h3>
<div class="content">
<p><i>route(address, args)</i><br/></p>
<p>Route messages received by the engine on the module’s port. Does
nothing by default, method should be overriden in subclasses. Not called
on submodules.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>address</code>: osc address</li>
<li><code>args</code>: list of values</li>
</ul>
<p><strong>Return</strong></p>
<p><code>False</code> if the message should not be passed to the
engine’s active route after being processed by the module.</p>
</div>
<h3 id="module.send">Module.send()</h3>
<div class="content">
<p><i>send(address, *args)</i><br/></p>
<p>Send message to the module’s port.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>address</code>: osc address</li>
<li><code>*args</code>: values, or (typetag, value) tuples</li>
</ul>
</div>
<h3 id="module.start_scene">Module.start_scene()</h3>
<div class="content">
<p><i>start_scene(name, scene, *args, **kwargs)</i><br/></p>
<p>Start scene in a thread. If a scene with the same name is already
running, it will be stopped. Scenes should be implemented as methods of
the object or lambda functions and can call self.wait() and
self.play_sequence() to create timed sequences or loops. Different
objects may call a scene with the same name simultaneously.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: scene name</li>
<li><code>scene</code>: function or method</li>
<li><code>*args</code>: arguments for the scene function</li>
<li><code>**kwargs</code>: keyword arguments for the scene function</li>
</ul>
</div>
<h3 id="module.restart_scene">Module.restart_scene()</h3>
<div class="content">
<p><i>restart_scene(name)</i><br/></p>
<p>Restart a scene that’s already running. Does nothing if the scene is
not running.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: scene name, with wildcard (’*‘) and range (’[]’)
support</li>
</ul>
</div>
<h3 id="module.stop_scene">Module.stop_scene()</h3>
<div class="content">
<p><i>stop_scene(name)</i><br/></p>
<p>Stop scene thread.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: scene name, with wildcard support</li>
</ul>
</div>
<h3 id="module.wait">Module.wait()</h3>
<div class="content">
<p><i>wait(duration, mode=‘beats’)</i><br/></p>
<p>Wait for given amount of time. Can only be called in scenes.
Subsequent calls to wait() in a scene do not drift with time and can be
safely used to create beat sequences. The engine’s <code>tempo</code>
must be set for the <code>beats</code> mode to work.</p>
<pre><code># Example
beat_1()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1&#39;s exec time
beat_2()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1 and beat_2&#39;s exec time</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>duration</code>: amount of time to wait</li>
<li><code>mode</code>: ‘beats’ or ‘seconds’ (only the first letter
matters)</li>
</ul>
</div>
<h3 id="module.wait_next_cycle">Module.wait_next_cycle()</h3>
<div class="content">
<p><i>wait_next_cycle()</i><br/></p>
<p>Wait until next cycle begins. The engine’s <code>tempo</code> and
<code>cycle_length</code> must be set and the engine’s
<code>start_cycle()</code> method must be called at the beginning of a
cycle for this to work.</p>
</div>
<h3 id="module.lock">Module.lock()</h3>
<div class="content">
<p><i>lock()</i><br/></p>
<p>Returns the engine’s main loop lock. Can only be called in scenes.
While held, the engine’s main loop will be paused (no message will be
processed, parameter changes won’t be applied).</p>
<p>This can be used when multiple parameter changes <em>must</em> happen
within a single processing cycle and prevent sending unnecessary
intermediate values (example 1).</p>
<p><strong>Examples</strong></p>
<pre><code># example 1
with self.lock():
    # reset all parameters
    module_a.reset()
    # set a parameter, but if its value
    # was the same before being reset
    # no message will be sent
    module_a.set(&#39;some_param&#39;, 1)
</code></pre>
</div>
<h3 id="module.run">Module.run()</h3>
<div class="content">
<p><i>run(callback, *args, **kwargs)</i><br/></p>
<p>Run callback in the mainthread. Can only be called in scenes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>callback</code>: function or method</li>
<li><code>*args</code>: arguments for the scene function</li>
<li><code>**kwargs</code>: keyword arguments for the scene function</li>
</ul>
</div>
<h3 id="module.play_sequence">Module.play_sequence()</h3>
<div class="content">
<p><i>play_sequence(sequence, loop=True)</i><br/></p>
<p>Play a sequence of actions scheduled on arbitrary beats. Can only be
called in scenes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>sequence</code>:
<ul>
<li><code>dict</code> with beat numbers (1-indexed, quarter note based)
as keys and lambda functions as values</li>
<li><code>list</code> of <code>dict</code> sequences (one sequence = one
bar)</li>
<li>sequences may contain an extra ‘signature’ string to change the time
signature. If not provided in the first sequence, the signature takes
the engine’s cycle length value.</li>
</ul></li>
<li><code>loop</code>: if <code>False</code>, the sequence will play
only once, otherwise it will loop until the scene is stopped</li>
</ul>
<p><strong>Example</strong></p>
<pre><code># single-bar sequence
play_sequence({
    &#39;signature&#39;: &#39;4/4&#39;,
    # beat 1
    1: lambda: guitar.set(&#39;mute&#39;, 1),
    # beat 3
    3: lambda: [guitar.set(&#39;mute&#39;, 0), guitar.set(&#39;disto&#39;, 1)],
    # &quot;and&quot; of beat 4
    4.5: lambda: guitar.set(&#39;disto&#39;, 0),
})

# multi-bar sequence
play_sequence([
    {   # bar 1
        &#39;signature&#39;: &#39;4/4&#39;,
        # beat 1
        1: lambda: voice.set(&#39;autotune&#39;, 1),
    },
    {}, # bar 2 (empty)
    {   # bar 3 (empty, but in 3/4)
        &#39;signature&#39;: &#39;3/4&#39;,
    },
    {   # bar 4 (in 3/4 too)
        # beat 1
        1: lambda: foo.set(&#39;autotune&#39;, 0),
        # beat 3
        3: lambda: foo.set(&#39;autotune&#39;, 1),
    }
])</code></pre>
</div>
<h3 id="module.add_event_callback">Module.add_event_callback()</h3>
<div class="content">
<p><i>add_event_callback(event, callback)</i><br/></p>
<p>Bind a callback function to an event. See <a
href="#module">Module</a> and <a href="#engine">Engine</a> for existing
events.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>event</code>: name of event</li>
<li><code>callback</code>: function or method. The callback’s signature
must match the event’s arguments.</li>
</ul>
</div>
<h3 id="module.dispatch_event">Module.dispatch_event()</h3>
<div class="content">
<p><i>dispatch_event(event, *args)</i><br/></p>
<p>Dispatch event to bound callback functions. Unless the callback
returns <code>False</code>, the event will be passed to the parent
module until it reaches the engine module.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>event</code>: name of event</li>
<li><code>*args</code>: arguments for the callback function</li>
</ul>
</div>
<hr />
<h2 id="route">Route</h2>
<p>Routing object that processes messages received by the engine when
active.</p>
<p><strong>Instance properties</strong></p>
<ul>
<li><code>engine</code>: Engine instance</li>
<li><code>logger</code>: python logger</li>
</ul>
<h3 id="route-1">Route()</h3>
<div class="content">
<p><i>Route(name)</i><br/></p>
<p>Route object constructor.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: route name</li>
</ul>
</div>
<h3 id="route.activate">Route.activate()</h3>
<div class="content">
<p><i>activate()</i><br/></p>
<p>Called when the engine switches to this route.</p>
</div>
<h3 id="route.deactivate">Route.deactivate()</h3>
<div class="content">
<p><i>deactivate()</i><br/></p>
<p>Called when the engine switches to another route.</p>
</div>
<h3 id="route.route">Route.route()</h3>
<div class="content">
<p><i>route(protocol, port, address, args)</i><br/></p>
<p>Process messages received by the engine.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>protocol</code>: ‘osc’, ‘osc.tcp’ or ‘midi’</li>
<li><code>port</code>: name of module or port number if unknown</li>
<li><code>address</code>: osc address</li>
<li><code>args</code>: list of values</li>
</ul>
</div>
<h3 id="route.start_scene">Route.start_scene()</h3>
<div class="content">
<p><i>start_scene(name, scene, *args, **kwargs)</i><br/></p>
<p>Start scene in a thread. If a scene with the same name is already
running, it will be stopped. Scenes should be implemented as methods of
the object or lambda functions and can call self.wait() and
self.play_sequence() to create timed sequences or loops. Different
objects may call a scene with the same name simultaneously.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: scene name</li>
<li><code>scene</code>: function or method</li>
<li><code>*args</code>: arguments for the scene function</li>
<li><code>**kwargs</code>: keyword arguments for the scene function</li>
</ul>
</div>
<h3 id="route.restart_scene">Route.restart_scene()</h3>
<div class="content">
<p><i>restart_scene(name)</i><br/></p>
<p>Restart a scene that’s already running. Does nothing if the scene is
not running.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: scene name, with wildcard (’*‘) and range (’[]’)
support</li>
</ul>
</div>
<h3 id="route.stop_scene">Route.stop_scene()</h3>
<div class="content">
<p><i>stop_scene(name)</i><br/></p>
<p>Stop scene thread.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>name</code>: scene name, with wildcard support</li>
</ul>
</div>
<h3 id="route.wait">Route.wait()</h3>
<div class="content">
<p><i>wait(duration, mode=‘beats’)</i><br/></p>
<p>Wait for given amount of time. Can only be called in scenes.
Subsequent calls to wait() in a scene do not drift with time and can be
safely used to create beat sequences. The engine’s <code>tempo</code>
must be set for the <code>beats</code> mode to work.</p>
<pre><code># Example
beat_1()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1&#39;s exec time
beat_2()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1 and beat_2&#39;s exec time</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>duration</code>: amount of time to wait</li>
<li><code>mode</code>: ‘beats’ or ‘seconds’ (only the first letter
matters)</li>
</ul>
</div>
<h3 id="route.wait_next_cycle">Route.wait_next_cycle()</h3>
<div class="content">
<p><i>wait_next_cycle()</i><br/></p>
<p>Wait until next cycle begins. The engine’s <code>tempo</code> and
<code>cycle_length</code> must be set and the engine’s
<code>start_cycle()</code> method must be called at the beginning of a
cycle for this to work.</p>
</div>
<h3 id="route.lock">Route.lock()</h3>
<div class="content">
<p><i>lock()</i><br/></p>
<p>Returns the engine’s main loop lock. Can only be called in scenes.
While held, the engine’s main loop will be paused (no message will be
processed, parameter changes won’t be applied).</p>
<p>This can be used when multiple parameter changes <em>must</em> happen
within a single processing cycle and prevent sending unnecessary
intermediate values (example 1).</p>
<p><strong>Examples</strong></p>
<pre><code># example 1
with self.lock():
    # reset all parameters
    module_a.reset()
    # set a parameter, but if its value
    # was the same before being reset
    # no message will be sent
    module_a.set(&#39;some_param&#39;, 1)
</code></pre>
</div>
<h3 id="route.run">Route.run()</h3>
<div class="content">
<p><i>run(callback, *args, **kwargs)</i><br/></p>
<p>Run callback in the mainthread. Can only be called in scenes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>callback</code>: function or method</li>
<li><code>*args</code>: arguments for the scene function</li>
<li><code>**kwargs</code>: keyword arguments for the scene function</li>
</ul>
</div>
<h3 id="route.play_sequence">Route.play_sequence()</h3>
<div class="content">
<p><i>play_sequence(sequence, loop=True)</i><br/></p>
<p>Play a sequence of actions scheduled on arbitrary beats. Can only be
called in scenes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>sequence</code>:
<ul>
<li><code>dict</code> with beat numbers (1-indexed, quarter note based)
as keys and lambda functions as values</li>
<li><code>list</code> of <code>dict</code> sequences (one sequence = one
bar)</li>
<li>sequences may contain an extra ‘signature’ string to change the time
signature. If not provided in the first sequence, the signature takes
the engine’s cycle length value.</li>
</ul></li>
<li><code>loop</code>: if <code>False</code>, the sequence will play
only once, otherwise it will loop until the scene is stopped</li>
</ul>
<p><strong>Example</strong></p>
<pre><code># single-bar sequence
play_sequence({
    &#39;signature&#39;: &#39;4/4&#39;,
    # beat 1
    1: lambda: guitar.set(&#39;mute&#39;, 1),
    # beat 3
    3: lambda: [guitar.set(&#39;mute&#39;, 0), guitar.set(&#39;disto&#39;, 1)],
    # &quot;and&quot; of beat 4
    4.5: lambda: guitar.set(&#39;disto&#39;, 0),
})

# multi-bar sequence
play_sequence([
    {   # bar 1
        &#39;signature&#39;: &#39;4/4&#39;,
        # beat 1
        1: lambda: voice.set(&#39;autotune&#39;, 1),
    },
    {}, # bar 2 (empty)
    {   # bar 3 (empty, but in 3/4)
        &#39;signature&#39;: &#39;3/4&#39;,
    },
    {   # bar 4 (in 3/4 too)
        # beat 1
        1: lambda: foo.set(&#39;autotune&#39;, 0),
        # beat 3
        3: lambda: foo.set(&#39;autotune&#39;, 1),
    }
])</code></pre>
</div>
<hr />
        </main>

    </body>
</html>
